#!/usr/bin/env php
<?php

// extract-compliance-data './path/to/compliance-report.pdf' './path/to/output.csv'

require __DIR__ . '/vendor/autoload.php';

$compliance_report_path = (isset($argv[1]) ? $argv[1] : null);
$output_csv_path = (isset($argv[2]) ? $argv[2] : null);

function err ($message) {
    error_log($message, 0, 'php://stderr');
}

function out ($message) {
    echo $message;
    echo "\n";
}

if (!is_readable($compliance_report_path)) {
    err("The compliance report path parameter is not readable.");
    exit(1);
}

$output_csv_directory = dirname($output_csv_path);
if (!is_dir($output_csv_directory) OR !is_writable($output_csv_directory)) {
    err("The directory for the output CSV path parameter is not a directory or is not writable.");
    exit(1);
}

$compliance_report_path = realpath($compliance_report_path);

if ((new \finfo(FILEINFO_MIME_TYPE))->file($compliance_report_path) != 'application/pdf') {
    err('The compliance report file is not a PDF file.');
    exit(1);
}

try {

    $parser = new \Smalot\PdfParser\Parser();
    $pdf = $parser->parseFile($compliance_report_path);

    foreach($pdf->getPages() as $page_number => $page) {

        $page_number++;
        $page_text = $page->getText();

        // 1 package serial number per page
        $package_serial_number = (preg_match('/Package S\/N: *([^\s]+)/', $page_text, $matches)) 
            ? $matches[1] : null;

        // 1 package name per page
        $package_name = (preg_match('/^Package Name: *([^\s]+)/m', $page_text, $matches)) 
            ? $matches[1] : null;

        // there can be more than 1 service bulletin tables in a page, but there must be at least 1
        // or else we are skipping the page
        $table_count = preg_match_all('/^service bulletins (in work|completed) as of (\w{3} \w, \w{4})/mi', $page_text, $matches);
        $service_bulletin_statuses = $matches[1];
        $service_bulletin_status_dates = $matches[2];

        if ($table_count < 1) {
            
            err("Skipping page $page_number for '$compliance_report_path' because there are no service bulletins.");
            continue;

        } elseif ($table_count == 1) {

            $table_texts = [$page_text];

        } else {

            // preg_split will always return 1 element (even if empty) prior to the match, this can happen if the 
            // match is at the very beginning of the haystack string
            // this way we can slice it off safely
            // every match of the regular expression results in 1 extra element in the result (even if empty)
            $table_texts = array_slice(
                preg_split('/^service bulletins in (?:work|completed) as of \w{3} \w, \w{4}/mi', $page_text), 
                1
            );

        }

        // should be 1 to 1 for pages
        var_dump($package_serial_number);
        var_dump($package_name);

        // should be 1 to 1 for tables
        var_dump($service_bulletin_statuses);
        var_dump($service_bulletin_status_dates);

        // every table has multiple rows
        var_dump($table_texts);

        $rows = [];

        // for every table, we need to extract the rows
        for ($i = 0; $i < $table_count; $i++) {

            $table_text = $table_texts[$i];

            // this tells us how many rows
            $row_count = preg_match_all('/^Service[\s]*Bulletin[\s]*(\d+\.\d+\/\d+(?: *[A-Za-z](?![A-Za-z0-9]))?)/m', $table_text, $matches);
            $bulletin_numbers = $matches[1];

            if ($row_count < 1) {
                err("Skipping table $i at page $page_number for '$compliance_report_path' because there are no rows.");
                continue;
            } elseif ($row_count == 1) {
                $row_texts = [$table_text];
            } else {
                $row_texts = array_slice(
                    preg_split('/^Service[\s]*Bulletin[\s]*(\d+\.\d+\/\d+(?: *[A-Za-z](?![A-Za-z0-9]))?)/', $table_text), 
                    1
                );
            }

            for ($j = 0; $j < $row_count; $j++) {

                $row_text = $row_texts[$j];

                $bulletin_engine_serial_number = (preg_match('/(OH[A-Z]\d\d-[A-Z]\d\d\d\d)/', $row_text, $matches)) 
                    ? $matches[1] : null;

                $bulletin_comment = (preg_match('/(\d\d\/\d\d\/\d\d: [\S\s]+?)^(?:Service|Caterpillar:)/m', $row_text, $matches)) 
                    ? $matches[1] : null;

                $rows[] = [
                    'PACKAGE SERIAL NUMBER'         => $package_serial_number,
                    'PACKAGE NAME'                  => $package_name,
                    'BULLETIN STATUS'               => $service_bulletin_statuses[$i],
                    'BULLETIN DATE'                 => $service_bulletin_status_dates[$i],
                    'BULLETIN NUMBER'               => $bulletin_numbers[$j],
                    'BULLETIN ENGINE SERIAL NUMBER' => $bulletin_engine_serial_number,
                    'BULLETIN COMMENTS'             => $bulletin_comment,
                ];

            }

        }

    }
    
} catch (\Exception $e) {

    err("Error parsing this file: '$compliance_report_path'");
    err("    Exception Message: {$e->getCode()} {$e->getMessage()}");
    exit(1);

}

var_dump($rows);